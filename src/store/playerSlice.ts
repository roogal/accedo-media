/*
 * @author BSG <dev@bsgroup.eu>
 * @copyright Better Software Group S.A.
 * @version: 1.0
 */
import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";

import { PlayerService } from "../services";
import { IPlaylistItemModel } from "../models";

const playerService = new PlayerService();

export interface IPlayerState {
  current?: IPlaylistItemModel;

  playlist: IPlaylistItemModel[];

  error?: string;

  pending?: boolean;
}

const initialState: IPlayerState = {
  playlist: [],
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const getPlaylist = createAsyncThunk<IPlaylistItemModel[], void>(
  "player/getPlaylist",
  async () => {
    return playerService.get();
  }
);

export const addPlaylistItem = createAsyncThunk<
  IPlaylistItemModel,
  { url: string }
>("player/addPlaylistItem", async (payload) => {
  return playerService.add(payload.url);
});

export const deletePlaylistItem = createAsyncThunk<string, string>(
  "player/deletePlaylistItem",
  async (payload) => {
    return playerService.delete(payload);
  }
);

export const playerSlice = createSlice({
  name: "player",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    clearPlaylist: (state) => {
      state.playlist = [];
    },
    setCurrent: (state, action: PayloadAction<IPlaylistItemModel>) => {
      state.current = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getPlaylist.pending, (state) => {
        state.pending = true;
        state.error = undefined;
      })
      .addCase(getPlaylist.fulfilled, (state, action) => {
        state.playlist = action.payload;
        state.pending = false;
      })
      .addCase(getPlaylist.rejected, (state, action) => {
        state.error = action.error?.message;
        state.pending = false;
      })
      .addCase(addPlaylistItem.pending, (state) => {
        state.pending = true;
        state.error = undefined;
      })
      .addCase(addPlaylistItem.fulfilled, (state, action) => {
        const list = state.playlist;
        list.push(action.payload);

        state.playlist = list;
        state.pending = false;
      })
      .addCase(addPlaylistItem.rejected, (state, action) => {
        state.error = action.error?.message;
        state.pending = false;
      })
      .addCase(deletePlaylistItem.pending, (state) => {
        state.pending = true;
        state.error = undefined;
      })
      .addCase(deletePlaylistItem.fulfilled, (state, action) => {
        const list = state.playlist;
        const index = list.findIndex((item) => item.id === action.payload);

        if (index >= 0) {
          list.splice(index, 1);
        }

        state.playlist = list;
        state.pending = false;
      })
      .addCase(deletePlaylistItem.rejected, (state, action) => {
        state.error = action.error?.message;
        state.pending = false;
      });
  },
});

/// Export actions
export const { clearPlaylist, setCurrent } = playerSlice.actions;

export default playerSlice.reducer;
